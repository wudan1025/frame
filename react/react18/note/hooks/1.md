# 1. 概念
> 不编写 class 的情况下使用 state 以及其他的 React 特性

> 可以让你在函数组件里“钩入” React state 及生命周期等特性的函数

> Hook 不能在 class 组件中使用

> Hook 使你在无需修改组件结构的情况下复用状态逻辑

# 2. 规则
> 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。

> 只能在 React 的函数组件 和 自定义的 Hook 中 调用 Hook。不要在其他 JavaScript 函数中调用

# 3. 常用hook
### state hook
>  const [count, setCount] = useState(0);

###### 读取 
> {变量名}

```javascript
<p>You clicked {count} times</p>
```

###### 更新
>  不需要使用 this

```javascript
  <button onClick={() => setCount(count + 1)}>
    Click me
  </button>
```

###### 多个 state
> 参考  https://zh-hans.reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables
```javascript 
// 定义
function Box() {
  const [state, setState] = useState({ left: 0, top: 0, width: 100, height: 100 });
  // ...
}

// 更新

useEffect(() => {
  function handleWindowMouseMove(e) {
    // 展开 「...state」 以确保我们没有 「丢失」 width 和 height
    setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
  }
  // 注意：这是个简化版的实现
  window.addEventListener('mousemove', handleWindowMouseMove);
  return () => window.removeEventListener('mousemove', handleWindowMouseMove);
}, []);
```

###  Effect Hook
> 函数组件增加了操作副作用的能力

> 副作用:执行过数据获取、订阅或者手动修改过 DOM

> 跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途, 只不过被合并成了一个 API

> React 将按照 effect 声明的顺序依次调用组件中的每一个 effect

##### 调用时机
> React 会在每次渲染后调用副作用函数

> 相当于 componentDidMount 和 componentDidUpdate

> 可以访问到组件的 props 和 state

##### 返回值
> 可以通过返回一个函数来指定如何“清除”副作用

### useContext 
> 不使用组件嵌套就可以订阅 React 的 Context

### useReducer
> useReducer 可以让你通过 reducer 来管理组件本地的复杂 state。