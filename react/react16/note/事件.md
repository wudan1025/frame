<!--
 * @LastEditors: wudan01
 * @description: 文件描述
-->

# 定义
### 命名 
> 小驼峰式命名: 首字母小写，后面大写

> eg: 点击 onClick


### 绑定事件
> {} 绑定事件

> event 是 react 复合事件 SyntheticEvent
```
function activateLasers(e) {
  console.log(e)
}

function stop(e) {
  // 失效
  // return false
  e.preventDefault()
}

// 事件
let el =
  <div>
    <button onClick={activateLasers}>
      激活按钮
    </button>
    <a href="http://www.baidu.com" onClick={stop}>默认跳转</a>
  </div>

const root = ReactDOM.createRoot(
    document.getElementById('example')
)

root.render(el)
```

### 传递参数
todo 传递多个如果?测试

# 注意
### 绑定事件 this 指向

##### 方案1 
> 使用bind

```
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true };

    // 为了在回调中使用 `this`，这个绑定是必不可少的
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}

const root = ReactDOM.createRoot(
  document.getElementById('example')
)

root.render(<Toggle />)
```

##### 方案2
> 使用箭头函数

> 方法使用箭头函数
```
class LoggingButton extends React.Component {
  // 此语法确保 `handleClick` 内的 `this` 已被绑定。
  // 注意: 这是 *实验性* 语法。
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
```

> 绑定时使用箭头函数(不建议使用)

> 每次渲染 LoggingButton 时都会创建不同的回调函数，如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染
```
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    return (
      <button onClick={() => this.handleClick()}>
        Click me
      </button>
    );
  }
}
```